/**
 * Targeted Test Runner for Dependency Updates
 * 
 * This script runs targeted tests for each updated dependency based on
 * the impact analysis generated by dependency-impact-analysis.js.
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');

// Configuration
const IMPACT_ANALYSIS_FILE = path.resolve(process.cwd(), '.github/dependency-impact.json');
const TEST_RESULTS_FILE = path.resolve(process.cwd(), '.github/dependency-test-results.json');
const TEST_ENV_DIR = path.resolve(process.cwd(), '.test-env');

// Load impact analysis
let impactAnalysis = {};
try {
  const analysisData = JSON.parse(fs.readFileSync(IMPACT_ANALYSIS_FILE, 'utf8'));
  impactAnalysis = analysisData.impactAnalysis || {};
  testConfigurations = analysisData.testConfigurations || {};
  console.log(`Loaded impact analysis for ${Object.keys(impactAnalysis).length} packages`);
} catch (error) {
  console.error(`Error loading impact analysis: ${error.message}`);
  process.exit(1);
}

/**
 * Create a temporary test environment for a dependency update
 */
function createTestEnvironment(packageName, packageVersion, packageType) {
  console.log(`Creating test environment for ${packageName}@${packageVersion}`);
  
  // Create test environment directory if it doesn't exist
  if (!fs.existsSync(TEST_ENV_DIR)) {
    fs.mkdirSync(TEST_ENV_DIR, { recursive: true });
  }
  
  const packageDir = path.join(TEST_ENV_DIR, packageName);
  
  // Remove existing package directory if it exists
  if (fs.existsSync(packageDir)) {
    fs.rmSync(packageDir, { recursive: true, force: true });
  }
  
  // Create package directory
  fs.mkdirSync(packageDir, { recursive: true });
  
  // Copy project files to test environment
  // Exclude node_modules, .git, and other large directories
  execSync(`cp -r ${process.cwd()}/* ${packageDir} --exclude node_modules --exclude .git --exclude dist --exclude build`, { stdio: 'inherit' });
  
  if (packageType === 'node') {
    // Update package.json with the new dependency version
    const packageJsonPath = path.join(packageDir, 'package.json');
    
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      let updated = false;
      if (packageJson.dependencies && packageJson.dependencies[packageName]) {
        packageJson.dependencies[packageName] = packageVersion;
        updated = true;
      }
      
      if (packageJson.devDependencies && packageJson.devDependencies[packageName]) {
        packageJson.devDependencies[packageName] = packageVersion;
        updated = true;
      }
      
      if (updated) {
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
        console.log(`Updated ${packageName} to ${packageVersion} in package.json`);
      }
    }
  } else if (packageType === 'python') {
    // Update Python requirements with the new dependency version
    const requirementsPath = path.join(packageDir, 'requirements.txt');
    const ragRequirementsPath = path.join(packageDir, 'requirements-rag.txt');
    
    const updateRequirementsFile = (filePath) => {
      if (fs.existsSync(filePath)) {
        let requirements = fs.readFileSync(filePath, 'utf8');
        
        // Update the package version in requirements.txt
        const packageRegex = new RegExp(`^${packageName}[=~<>]+.*$`, 'm');
        const updatedRequirements = requirements.replace(
          packageRegex,
          `${packageName}==${packageVersion}`
        );
        
        fs.writeFileSync(filePath, updatedRequirements);
        console.log(`Updated ${packageName} to ${packageVersion} in ${filePath}`);
      }
    };
    
    updateRequirementsFile(requirementsPath);
    updateRequirementsFile(ragRequirementsPath);
  }
  
  return packageDir;
}

/**
 * Run Jest tests for Node.js packages
 */
async function runJestTests(packageDir, testConfig) {
  return new Promise((resolve, reject) => {
    console.log(`Running Jest tests in ${packageDir}`);
    
    // Build Jest command
    const testPatterns = testConfig.testPatterns || [];
    const jestArgs = [
      '--no-watchman',
      '--colors',
      '--passWithNoTests',
      '--json',
      '--outputFile=test-results.json',
      ...testPatterns
    ];
    
    console.log(`Jest command: npx jest ${jestArgs.join(' ')}`);
    
    // Run Jest
    const jest = spawn('npx', ['jest', ...jestArgs], {
      cwd: packageDir,
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    let stdout = '';
    let stderr = '';
    
    jest.stdout.on('data', (data) => {
      stdout += data.toString();
      console.log(data.toString());
    });
    
    jest.stderr.on('data', (data) => {
      stderr += data.toString();
      console.error(data.toString());
    });
    
    jest.on('close', (code) => {
      console.log(`Jest exited with code ${code}`);
      
      // Read test results
      try {
        const resultsPath = path.join(packageDir, 'test-results.json');
        if (fs.existsSync(resultsPath)) {
          const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
          resolve({
            success: code === 0,
            results,
            stdout,
            stderr
          });
        } else {
          resolve({
            success: code === 0,
            results: null,
            stdout,
            stderr,
            error: 'No test results file found'
          });
        }
      } catch (error) {
        resolve({
          success: false,
          results: null,
          stdout,
          stderr,
          error: error.message
        });
      }
    });
  });
}

/**
 * Run pytest tests for Python packages
 */
async function runPytestTests(packageDir, testConfig) {
  return new Promise((resolve, reject) => {
    console.log(`Running pytest in ${packageDir}`);
    
    // Build pytest command
    const testPatterns = testConfig.testPatterns || [];
    const pytestArgs = [
      '-v',
      '--json-report',
      '--json-report-file=test-results.json',
      ...testPatterns
    ];
    
    console.log(`pytest command: python -m pytest ${pytestArgs.join(' ')}`);
    
    // Run pytest
    const pytest = spawn('python', ['-m', 'pytest', ...pytestArgs], {
      cwd: packageDir,
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    let stdout = '';
    let stderr = '';
    
    pytest.stdout.on('data', (data) => {
      stdout += data.toString();
      console.log(data.toString());
    });
    
    pytest.stderr.on('data', (data) => {
      stderr += data.toString();
      console.error(data.toString());
    });
    
    pytest.on('close', (code) => {
      console.log(`pytest exited with code ${code}`);
      
      // Read test results
      try {
        const resultsPath = path.join(packageDir, 'test-results.json');
        if (fs.existsSync(resultsPath)) {
          const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
          resolve({
            success: code === 0,
            results,
            stdout,
            stderr
          });
        } else {
          resolve({
            success: code === 0,
            results: null,
            stdout,
            stderr,
            error: 'No test results file found'
          });
        }
      } catch (error) {
        resolve({
          success: false,
          results: null,
          stdout,
          stderr,
          error: error.message
        });
      }
    });
  });
}

/**
 * Format test results for reporting
 */
function formatTestResults(packageName, testResults, packageType) {
  if (!testResults) {
    return {
      packageName,
      success: false,
      testsPassed: 0,
      testsFailed: 0,
      testsTotal: 0,
      duration: 0,
      error: 'No test results available',
      details: []
    };
  }
  
  if (packageType === 'node') {
    // Format Jest results
    const results = testResults.results;
    
    return {
      packageName,
      success: results.success,
      testsPassed: results.numPassedTests,
      testsFailed: results.numFailedTests,
      testsTotal: results.numTotalTests,
      duration: results.startTime ? (results.endTime - results.startTime) / 1000 : 0,
      error: results.success ? null : 'Tests failed',
      details: results.testResults.map(result => ({
        name: result.name,
        status: result.status,
        duration: result.endTime ? (result.endTime - result.startTime) / 1000 : 0,
        failureMessages: result.failureMessages || []
      }))
    };
  } else if (packageType === 'python') {
    // Format pytest results
    const results = testResults.results;
    
    return {
      packageName,
      success: results.summary.failed === 0,
      testsPassed: results.summary.passed,
      testsFailed: results.summary.failed,
      testsTotal: results.summary.total,
      duration: results.duration,
      error: results.summary.failed > 0 ? 'Tests failed' : null,
      details: results.tests.map(test => ({
        name: test.nodeid,
        status: test.outcome,
        duration: test.duration,
        failureMessages: test.call?.traceback ? [test.call.traceback] : []
      }))
    };
  }
  
  return {
    packageName,
    success: false,
    testsPassed: 0,
    testsFailed: 0,
    testsTotal: 0,
    duration: 0,
    error: 'Unknown package type',
    details: []
  };
}

/**
 * Generate a markdown summary from test results
 */
function generateMarkdownSummary(allResults) {
  let summary = '# Dependency Update Test Results\n\n';
  
  // Overall summary
  const totalPackages = allResults.length;
  const successfulUpdates = allResults.filter(result => result.success).length;
  const failedUpdates = totalPackages - successfulUpdates;
  
  summary += `## Overview\n\n`;
  summary += `- Total packages tested: ${totalPackages}\n`;
  summary += `- Successful updates: ${successfulUpdates}\n`;
  summary += `- Failed updates: ${failedUpdates}\n\n`;
  
  // Package details
  summary += `## Package Details\n\n`;
  
  allResults.forEach(result => {
    const icon = result.success ? '✅' : '❌';
    summary += `### ${icon} ${result.packageName}\n\n`;
    summary += `- Status: ${result.success ? 'Passed' : 'Failed'}\n`;
    summary += `- Tests: ${result.testsPassed}/${result.testsTotal} passed`;
    
    if (result.testsFailed > 0) {
      summary += ` (${result.testsFailed} failed)`;
    }
    
    summary += `\n- Duration: ${result.duration.toFixed(2)}s\n`;
    
    if (result.error) {
      summary += `- Error: ${result.error}\n`;
    }
    
    if (result.testsFailed > 0 && result.details) {
      summary += `\n#### Failed Tests\n\n`;
      
      const failedTests = result.details.filter(detail => 
        detail.status === 'failed' || detail.failureMessages.length > 0
      );
      
      failedTests.forEach(test => {
        summary += `- **${test.name}**\n`;
        
        if (test.failureMessages && test.failureMessages.length > 0) {
          summary += `  <details><summary>Show Error</summary>\n\n`;
          summary += `  \`\`\`\n${test.failureMessages.join('\n')}\n  \`\`\`\n\n`;
          summary += `  </details>\n`;
        }
      });
    }
    
    summary += '\n';
  });
  
  return summary;
}

/**
 * Main function to run all tests
 */
async function runAllTests() {
  console.log('Starting targeted tests for dependency updates...');
  
  const allResults = [];
  
  // Run tests for each package
  for (const packageName in testConfigurations) {
    const testConfig = testConfigurations[packageName];
    const impact = impactAnalysis[packageName] || {};
    const updateType = impact.updateType || 'unknown';
    const packageType = impact.packageType || testConfig.packageType || 'node';
    
    console.log(`\n--- Testing ${packageName} (${updateType} update) ---\n`);
    
    // Create test environment
    const packageDir = createTestEnvironment(packageName, 'latest', packageType);
    
    // Run tests
    let testResults;
    
    if (packageType === 'node') {
      // Run Jest tests
      testResults = await runJestTests(packageDir, testConfig);
    } else if (packageType === 'python') {
      // Run pytest tests
      testResults = await runPytestTests(packageDir, testConfig);
    }
    
    // Format and save results
    const formattedResults = formatTestResults(packageName, testResults, packageType);
    allResults.push(formattedResults);
    
    console.log(`\n--- Completed tests for ${packageName} ---\n`);
    console.log(`Success: ${formattedResults.success}`);
    console.log(`Tests: ${formattedResults.testsPassed}/${formattedResults.testsTotal} passed`);
    
    if (formattedResults.testsFailed > 0) {
      console.log(`Failed: ${formattedResults.testsFailed} tests`);
    }
  }
  
  // Save all test results
  fs.writeFileSync(TEST_RESULTS_FILE, JSON.stringify(allResults, null, 2));
  console.log(`\nAll test results saved to ${TEST_RESULTS_FILE}`);
  
  // Generate markdown summary
  const markdownSummary = generateMarkdownSummary(allResults);
  fs.writeFileSync(path.join(process.cwd(), '.github/test-results-summary.md'), markdownSummary);
  console.log(`Test results summary saved to .github/test-results-summary.md`);
  
  // Determine overall success
  const overallSuccess = allResults.every(result => result.success);
  
  if (overallSuccess) {
    console.log(`\n✅ All dependency updates passed their tests!`);
    process.exit(0);
  } else {
    console.log(`\n❌ Some dependency updates failed their tests.`);
    process.exit(1);
  }
}

// Run all tests
runAllTests().catch(error => {
  console.error(`Error running tests: ${error.message}`);
  console.error(error.stack);
  process.exit(1);
});