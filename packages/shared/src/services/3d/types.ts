/**
 * Base types for 3D services
 */

export interface Material {
  type: string;
  properties: Record<string, any>;
  textures?: Record<string, string>;
}

export interface Scene3D {
  id: string;
  name: string;
  elements: Array<{
    id: string;
    type: string;
    name?: string;
    position: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number };
    dimensions: { width: number; height: number; depth: number };
    mesh?: {
      vertices: number[][];
      normals?: number[][];
      uvs?: number[][];
      indices?: number[];
    };
    material?: {
      type: string;
      properties: Record<string, any>;
      textures?: Record<string, string>;
    };
    metadata?: Record<string, any>;
    relationships?: Array<{
      type: string;
      target: string;
      targetName?: string;
      confidence?: number;
      attributes?: Record<string, any>;
    }>;
  }>;
  metadata?: Record<string, any>;
}

// Added export
export interface MaterialVisualizationOptions {
  quality: 'low' | 'medium' | 'high';
  textureResolution?: number;
  enableAR?: boolean;
  environmentMap?: string; // Legacy support
  lighting?: {
    environmentMap?: string; // User-provided specific environment map (override)
    intensity?: number;
    rotation?: number;
    toneMapping?: 'linear' | 'reinhard' | 'aces' | 'cineon';
    autoGenerate?: boolean; // Generate from material images if true
    defaultType?: 'neutral' | 'indoor' | 'outdoor' | 'studio'; // Default env map type if not autoGenerated
  };
  useMaterialNet?: boolean; // Whether to use MaterialNet for PBR property extraction
  textureEnhancement?: { // Options for enhancing existing textures
    enabled?: boolean;
    quality?: 'low' | 'medium' | 'high';
    scale?: number; // Upscaling factor
  };
  textToTexture?: { // Options for generating texture from text
    enabled?: boolean;
    prompt?: string; // Text prompt to generate texture
    style?: string;
    size?: number; // Size of the generated texture (width=height)
  };
}

// Added export
export interface ExtractedTextures {
  albedo?: string;
  normal?: string;
  roughness?: string;
  metallic?: string;
  ao?: string;
  displacement?: string;
}

// Added export
export interface HDREnvironmentMap {
  url: string;
  intensity: number;
  rotation: number;
  source: 'generated' | 'default' | 'custom';
  quality: 'low' | 'medium' | 'high';
  toneMapping: 'linear' | 'reinhard' | 'aces' | 'cineon';
}

// Added export
export interface EnvironmentMapOptions {
  quality?: 'low' | 'medium' | 'high';
  intensity?: number;
  rotation?: number;
  toneMapping?: 'linear' | 'reinhard' | 'aces' | 'cineon';
}


export interface ProcessingResult {
  success: boolean;
  data?: any;
  error?: string | Error;
  result?: any; // For backward compatibility and extended results
}

/**
 * Camera pose information from Structure-from-Motion processing
 */
export interface CameraPose {
  /** Name or identifier of the source image */
  name: string;
  /** Rotation matrix (3x3) */
  rotation: number[][];
  /** Translation vector (x, y, z) */
  translation: number[];
  /** Associated camera ID */
  camera_id: number;
}

/**
 * NeRF-compatible camera data format
 */
export interface NeRFCameraData {
  /** Camera field of view in radians */
  camera_angle_x: number;
  /** Array of camera frame data */
  frames: Array<{
    /** Path to the source image file */
    file_path: string;
    /** 4x4 transformation matrix (camera-to-world) */
    transform_matrix: number[][];
    /** Camera intrinsic parameters */
    fx?: number;
    fy?: number;
    cx?: number;
    cy?: number;
    width?: number;
    height?: number;
    /** Associated camera ID */
    camera_id?: number;
  }>;
}

export interface ModelEndpoints {
  // Image-based reconstruction
  nerfStudio: string;
  instantNgp: string;
  blenderProc: string;
  
  // Text-based generation
  shapE: string;
  get3d: string;
  hunyuan3d: string;
  
  // Scene understanding
  yolo: string;  // Object detection
  sam: string;   // Segmentation
  midas: string; // Depth estimation
  
  // Architectural
  architecturalRecognition: string;
  roomLayoutGenerator: string;
  
  // Material and style
  controlNet: string;
  text2material: string;
  clip: string;
  hdrnet: string;   // For lighting estimation and HDR environment maps
  
  // Camera pose estimation and multi-view consistency
  colmap: string;   // For Structure-from-Motion processing
  
  // Interior design automation
  spaceFormer: string; // For room layout and furniture placement
  
  // Point cloud processing and optimization
  pointE: string;   // For point cloud processing using Point-E
  
  // Scene graph generation for relational understanding
  sceneGraph: string; // For scene graph generation using 3DSSG

  // Texture Enhancement and Generation
  text2texture?: string; // Endpoint for Text2Texture service

  // Index signature removed to allow optional properties
  // [key: string]: string; 
}

/**
 * Scene graph node representing an object in a scene
 */
export interface SceneGraphNode {
  /** Unique identifier for the node */
  id: string;
  /** Type of object (wall, chair, table, etc.) */
  type: string;
  /** Display name for the object */
  label: string;
  /** 3D position of the object [x, y, z] */
  position: [number, number, number];
  /** Size of the object [width, height, depth] */
  size: [number, number, number];
  /** Confidence score for the node detection/classification (0-1) */
  confidence: number;
  /** Additional properties and metadata */
  attributes: Record<string, any>;
}

/**
 * Scene graph edge representing a relationship between objects
 */
export interface SceneGraphEdge {
  /** Unique identifier for the edge */
  id: string;
  /** ID of the source node */
  source: string;
  /** ID of the target node */
  target: string;
  /** Type of relationship (on, in, next_to, etc.) */
  type: string;
  /** Display name for the relationship */
  label: string;
  /** Confidence score for the relationship detection (0-1) */
  confidence: number;
  /** Additional properties and metadata */
  attributes: Record<string, any>;
}

/**
 * Complete scene graph representation with nodes and edges
 */
export interface SceneGraph {
  /** Array of nodes (objects) in the scene */
  nodes: SceneGraphNode[];
  /** Array of edges (relationships) in the scene */
  edges: SceneGraphEdge[];
  /** Metadata about the scene graph */
  metadata: {
    /** Timestamp when the scene graph was generated */
    timestamp?: string;
    /** Source of the scene graph */
    source?: string;
    /** Version information */
    version?: string;
    /** Any additional metadata */
    [key: string]: any;
  };
}

/**
 * Options for scene graph generation and processing
 */
export interface SceneGraphOptions {
  /** Minimum confidence threshold for nodes and edges (0-1) */
  minConfidence?: number;
  /** Maximum number of relationships to include */
  maxRelationships?: number;
  /** Whether to use cached results if available */
  useCache?: boolean;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Types of relationships to include */
  relationshipTypes?: string[];
  /** Types of objects to include */
  objectTypes?: string[];
  /** Whether to merge similar objects */
  mergeSimilarObjects?: boolean;
}

export interface ServiceError extends Error {
  name: string;
  message: string;
  code?: string;
  status?: number;
}

export function isServiceError(error: unknown): error is ServiceError {
  return error instanceof Error && 'name' in error && 'message' in error;
}

export interface ArchitecturalElement {
  id: string;
  type: 'wall' | 'window' | 'door' | 'furniture';
  position: { x: number; y: number; z: number };
  dimensions: { width: number; height: number; depth: number };
  rotation: { x: number; y: number; z: number };
  metadata?: {
    style?: string;
    material?: string;
    standardSize?: boolean;
    type?: string;
    
    // SpaceFormer additions
    purpose?: string;
    priority?: string;
    zone?: string;
    [key: string]: any; // Allow additional properties for flexibility
  };
}

export interface RoomLayout {
  id: string;
  name: string;
  dimensions: {
    width: number;
    length: number;
    height: number;
  };
  elements: ArchitecturalElement[];
  metadata: {
    style?: string;
    purpose?: string;
    standardsCompliance?: boolean;
    occupancyRate?: number;
    flowScore?: number;
    
    // SpaceFormer additions
    accessibilityScore?: number;
    designPrinciplesScores?: Record<string, number>;
    optimized?: boolean;
    score?: number;
    [key: string]: any; // Allow additional properties for flexibility
  };
  preview?: string; // Base64 encoded preview image
  thumbnail?: string; // Base64 encoded thumbnail image
}

export interface HouseGenerationConfig {
  style?: string;
  roomCount?: number;
  floorCount?: number;
  constraints?: {
    maxArea?: number;
    minArea?: number;
    requireGarage?: boolean;
    requireBasement?: boolean;
  };
  texturePreferences?: {
    exteriorStyle?: string;
    interiorStyle?: string;
    materialTypes?: string[];
  };
}

export interface HouseGenerationResult {
  outline: {
    sketch: string; // Base64 encoded image
    refined: string; // Base64 encoded image
  };
  shell: {
    model: string; // GLB format base64
    preview: string; // Base64 encoded preview
  };
  detailedScene: {
    model: string; // GLB format base64
    preview: string; // Base64 encoded preview
  };
  furniture: Array<{
    type: string;
    model: string; // GLB format base64
    position: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number };
  }>;
  textures: {
    exterior: Record<string, string>; // Material name -> Base64 texture maps
    interior: Record<string, string>; // Material name -> Base64 texture maps
  };
}

export interface ThreeDProvider {
  processImage(imageBuffer: Buffer, options: {
    detectObjects?: boolean;
    estimateDepth?: boolean;
    segmentScene?: boolean;
  }): Promise<ProcessingResult>;

  processText(text: string, options: {
    style?: string;
    constraints?: any;
  }): Promise<ProcessingResult>;

  generateVariations(scene: Scene3D, options: {
    count?: number;
    constraints?: {
      style?: string;
      budget?: number;
      materials?: string[];
    };
  }): Promise<Scene3D[]>;

  exportScene(scene: Scene3D, format: 'gltf' | 'obj' | 'fbx'): Promise<any>;
}

export interface ArchitecturalProvider extends ThreeDProvider {
  processArchitecturalDrawing(drawing: ArrayBuffer): Promise<RoomLayout>;
  generateRoomLayout(specifications: any): Promise<RoomLayout[]>;
  generateFurniturePlacement(layout: RoomLayout, requirements: any): Promise<any>;
}

export interface HouseGenerationProvider extends ThreeDProvider {
  generateHouse(description: string, config: HouseGenerationConfig): Promise<HouseGenerationResult>;
  refineResult(result: any, feedback: string, options?: any): Promise<any>;
}

export type GPUTier = 'low' | 'medium' | 'high';

export interface GPU_TIER_CONFIGS {
  [key: string]: {
    maxBatchSize: number;
    maxTextureSize: number;
    maxVertices: number;
    maxDrawCalls: number;
  };
}

export enum TaskPriority {
  LOW = 0,
  MEDIUM = 1,
  HIGH = 2
}

/**
 * Options for scene optimization using DiffusionNeRF
 */
export interface SceneOptimizationOptions {
  /** Whether to use cached results if available */
  useCache?: boolean;
  /** Quality level for reconstruction ('low', 'medium', 'high') */
  quality?: string;
  /** Force diffusion enhancement even when input quality is good */
  forceDiffusion?: boolean;
  /** Directory to save output files */
  outputDir?: string;
  /** Optional camera parameters if available from previous processing */
  cameraParams?: Record<string, any>;
}

export interface RESOURCE_THRESHOLDS {
  memory: {
    low: number;
    medium: number;
    high: number;
  };
  gpu: {
    low: number;
    medium: number;
    high: number;
  };
}

/**
 * Options for point cloud processing operations
 */
export interface PointCloudProcessingOptions {
  /** Whether to denoise the point cloud */
  denoise?: boolean;
  /** Denoising strength (0-1) */
  denoiseStrength?: number;
  /** Whether to simplify the point cloud */
  simplify?: boolean;
  /** Target point count after simplification */
  targetPointCount?: number;
  /** Whether to fill holes in the point cloud */
  fillHoles?: boolean;
  /** Whether to smooth the point cloud */
  smooth?: boolean;
  /** Number of smoothing iterations */
  smoothIterations?: number;
  /** Whether to generate a mesh from the point cloud */
  generateMesh?: boolean;
  /** Quality level for processing */
  quality?: 'low' | 'medium' | 'high';
  /** Whether to use caching for results */
  useCache?: boolean;
}

// --- Texture Enhancement Types ---

export interface TextureEnhancementOptions {
  quality?: 'low' | 'medium' | 'high';
  scale?: number;
  useCache?: boolean;
}

export interface TextToTextureOptions {
  style?: string;
  size?: number;
  useCache?: boolean;
}

export interface TextureResult extends ProcessingResult {
  outputPath?: string; // Path to the generated/enhanced texture (optional on error)
}