/**
 * PDF Processing Queue System
 *
 * This module provides a persistent, file-based queue system for PDF processing jobs,
 * supporting priorities, concurrency control, progress tracking, and error recovery.
 */

import * as fs from 'fs';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../../utils/logger';
import { processPdfCatalog } from './pdfProcessor';
import { createPdfQueueAdapter, QueueAdapter } from '../messaging/queueAdapter';
import { MessagePayload } from '../messaging/messageBroker';

// Queue Job Status Types
export type JobStatus =
  | 'pending'
  | 'processing'
  | 'completed'
  | 'failed'
  | 'retrying';

// Priority Levels
export type JobPriority = 'low' | 'normal' | 'high';

// Queue Job Interface
export interface QueueJob {
  id: string;
  filePath: string;
  options: {
    userId: string;
    catalogName: string;
    manufacturer?: string;
    extractImages?: boolean;
    extractText?: boolean;
    associateTextWithImages?: boolean;
    deleteOriginalAfterProcessing?: boolean;
  };
  status: JobStatus;
  priority: JobPriority;
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  attempts: number;
  maxAttempts: number;
  error?: string;
  progress?: {
    totalPages?: number;
    processedPages?: number;
    extractedImages?: number;
    processedImages?: number;
    materialsCreated?: number;
  };
}

// Queue Configuration
export interface QueueConfig {
  maxConcurrent: number;
  retryDelay: number;
  maxAttempts: number;
  persistPath: string;
  completedJobRetention: number; // In milliseconds
}

/**
 * PDF Processing Queue
 */
export class PDFQueue {
  private jobs: Map<string, QueueJob> = new Map();
  private processingJobs: Set<string> = new Set();
  private config: QueueConfig;
  private persistInterval: NodeJS.Timeout | null = null;
  private processInterval: NodeJS.Timeout | null = null;
  private isProcessing: boolean = false;
  private adapter: QueueAdapter;

  /**
   * Create a new PDF Queue
   * @param config Queue configuration
   */
  constructor(config?: Partial<QueueConfig>) {
    // Initialize the queue adapter
    this.adapter = createPdfQueueAdapter();
    // Default configuration
    this.config = {
      maxConcurrent: 3,
      retryDelay: 30000, // 30 seconds
      maxAttempts: 3,
      persistPath: path.join('.', 'data', 'pdf-queue'),
      completedJobRetention: 7 * 24 * 60 * 60 * 1000, // 7 days
      ...config
    };

    // Create persist directory if it doesn't exist
    if (!fs.existsSync(this.config.persistPath)) {
      fs.mkdirSync(this.config.persistPath, { recursive: true });
    }

    // Restore queue state
    this.restore();

    // Start persistence interval
    this.persistInterval = setInterval(() => this.persist(), 30000);

    // Start processing interval
    this.processInterval = setInterval(() => this.processNextBatch(), 1000);

    // Set up event handlers for cross-queue events
    this.setupEventHandlers();
  }

  /**
   * Set up event handlers for events from other queues
   */
  private async setupEventHandlers(): Promise<void> {
    try {
      await this.adapter.setupStandardEventHandlers({
        // Handle job completion events from crawler queue
        onJobCompleted: async (message: MessagePayload) => {
          // Example: log cross-queue events
          logger.info(`PDF Queue received completion event from ${message.source}: Job ${message.data.id}`);

          // Here you could implement logic to process PDF files generated by crawler jobs
          // For example, automatically adding PDFs from crawler results to the queue
        },

        // Handle failure events from crawler queue - could trigger cleanup or notification
        onJobFailed: async (message: MessagePayload) => {
          logger.info(`PDF Queue received failure event from ${message.source}: Job ${message.data.id}`);
        }
      });

      logger.info('PDF Queue event handlers initialized');
    } catch (err) {
      logger.error(`Failed to set up PDF Queue event handlers: ${err}`);
    }
  }

  /**
   * Add a PDF to the processing queue
   *
   * @param filePath Path to the PDF file
   * @param options Processing options
   * @returns Job ID
   */
  public async add(
    filePath: string,
    options: {
      userId: string;
      catalogName: string;
      manufacturer?: string;
      priority?: JobPriority;
      extractImages?: boolean;
      extractText?: boolean;
      associateTextWithImages?: boolean;
      deleteOriginalAfterProcessing?: boolean;
    }
  ): Promise<string> {
    // Validate file exists
    if (!fs.existsSync(filePath)) {
      throw new Error(`PDF file not found: ${filePath}`);
    }

    // Create new job
    const jobId = uuidv4();
    const job: QueueJob = {
      id: jobId,
      filePath,
      options: {
        userId: options.userId,
        catalogName: options.catalogName,
        manufacturer: options.manufacturer,
        extractImages: options.extractImages,
        extractText: options.extractText,
        associateTextWithImages: options.associateTextWithImages,
        deleteOriginalAfterProcessing: options.deleteOriginalAfterProcessing
      },
      status: 'pending',
      priority: options.priority || 'normal',
      createdAt: new Date(),
      attempts: 0,
      maxAttempts: this.config.maxAttempts,
      progress: {
        totalPages: 0,
        processedPages: 0,
        extractedImages: 0,
        processedImages: 0,
        materialsCreated: 0
      }
    };

    // Add job to queue
    this.jobs.set(jobId, job);

    // Persist queue state
    await this.persist();

    logger.info(`Added PDF to processing queue: ${filePath} (Job ID: ${jobId})`);

    // Publish job-added event to the message broker
    await this.adapter.publishJobAdded({
      id: jobId,
      status: 'pending',
      priority: job.priority,
      filePath: job.filePath,
      catalogName: job.options.catalogName,
      userId: job.options.userId,
      manufacturer: job.options.manufacturer
    });

    return jobId;
  }

  /**
   * Add multiple PDFs to the processing queue
   *
   * @param jobs Array of PDF jobs to add
   * @returns Array of job IDs
   */
  public async addBatch(
    jobs: Array<{
      filePath: string;
      options: {
        userId: string;
        catalogName: string;
        manufacturer?: string;
        priority?: JobPriority;
        extractImages?: boolean;
        extractText?: boolean;
        associateTextWithImages?: boolean;
        deleteOriginalAfterProcessing?: boolean;
      }
    }>
  ): Promise<string[]> {
    const jobIds: string[] = [];

    for (const job of jobs) {
      try {
        const jobId = await this.add(job.filePath, job.options);
        jobIds.push(jobId);
      } catch (err) {
        logger.error(`Failed to add PDF to queue: ${job.filePath} - ${err}`);
        // Continue with next job
      }
    }

    return jobIds;
  }

  /**
   * Get a job by ID
   *
   * @param jobId Job ID
   * @returns Job object or null if not found
   */
  public get(jobId: string): QueueJob | null {
    return this.jobs.get(jobId) || null;
  }

  /**
   * Get all jobs in the queue
   *
   * @param status Optional status filter
   * @returns Array of jobs
   */
  public getAll(status?: JobStatus): QueueJob[] {
    const jobs = Array.from(this.jobs.values());

    if (status) {
      return jobs.filter(job => job.status === status);
    }

    return jobs;
  }

  /**
   * Get job counts by status
   *
   * @returns Object with counts for each status
   */
  public getCounts(): Record<JobStatus, number> {
    const counts: Record<JobStatus, number> = {
      pending: 0,
      processing: 0,
      completed: 0,
      failed: 0,
      retrying: 0
    };

    for (const job of this.jobs.values()) {
      counts[job.status]++;
    }

    return counts;
  }

  /**
   * Remove a job from the queue
   *
   * @param jobId Job ID
   * @returns true if job was removed, false if not found
   */
  public remove(jobId: string): boolean {
    const job = this.jobs.get(jobId);

    if (!job) {
      return false;
    }

    // If job is processing, we can't remove it yet
    if (job.status === 'processing') {
      return false;
    }

    // Remove job
    this.jobs.delete(jobId);

    // Remove job file
    const jobFile = path.join(this.config.persistPath, `${jobId}.json`);
    if (fs.existsSync(jobFile)) {
      fs.unlinkSync(jobFile);
    }

    logger.info(`Removed job from queue: ${jobId}`);
    return true;
  }

  /**
   * Clean up completed and failed jobs older than the retention period
   *
   * @returns Number of jobs removed
   */
  public cleanup(): number {
    let removedCount = 0;
    const now = Date.now();
    const retentionCutoff = now - this.config.completedJobRetention;

    for (const [jobId, job] of this.jobs.entries()) {
      if (
        (job.status === 'completed' || job.status === 'failed') &&
        job.completedAt &&
        job.completedAt.getTime() < retentionCutoff
      ) {
        this.jobs.delete(jobId);
        removedCount++;

        // Remove job file
        const jobFile = path.join(this.config.persistPath, `${jobId}.json`);
        if (fs.existsSync(jobFile)) {
          fs.unlinkSync(jobFile);
        }
      }
    }

    if (removedCount > 0) {
      logger.info(`Cleaned up ${removedCount} old jobs from queue`);
    }

    return removedCount;
  }

  /**
   * Pause queue processing
   */
  public pause(): void {
    this.isProcessing = false;
    logger.info('PDF processing queue paused');
  }

  /**
   * Resume queue processing
   */
  public resume(): void {
    this.isProcessing = true;
    logger.info('PDF processing queue resumed');
    this.processNextBatch();
  }

  /**
   * Shutdown the queue gracefully
   */
  public async shutdown(): Promise<void> {
    logger.info('Shutting down PDF processing queue...');

    // Stop intervals
    if (this.persistInterval) {
      clearInterval(this.persistInterval);
      this.persistInterval = null;
    }

    if (this.processInterval) {
      clearInterval(this.processInterval);
      this.processInterval = null;
    }

    // Pause processing
    this.isProcessing = false;

    // Wait for processing jobs to complete
    if (this.processingJobs.size > 0) {
      logger.info(`Waiting for ${this.processingJobs.size} jobs to complete...`);
      // Wait for a maximum of 10 seconds
      const maxWaitTime = 10000;
      const startTime = Date.now();

      while (this.processingJobs.size > 0 && Date.now() - startTime < maxWaitTime) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    // Unsubscribe from all message broker events
    await this.adapter.unsubscribeAll();

    // Final persist
    await this.persist();
    logger.info('PDF processing queue shutdown complete');
  }

  /**
   * Process the next batch of jobs
   */
  private async processNextBatch(): Promise<void> {
    if (!this.isProcessing) {
      return;
    }

    // Check if we can process more jobs
    const availableSlots = this.config.maxConcurrent - this.processingJobs.size;
    if (availableSlots <= 0) {
      return;
    }

    // Get pending jobs sorted by priority
    const pendingJobs = Array.from(this.jobs.values())
      .filter(job => job.status === 'pending' || job.status === 'retrying')
      .sort((a, b) => {
        // Sort by priority first (high > normal > low)
        const priorityOrder: Record<JobPriority, number> = { high: 0, normal: 1, low: 2 };
        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
        if (priorityDiff !== 0) {
          return priorityDiff;
        }

        // Then by creation date (oldest first)
        return a.createdAt.getTime() - b.createdAt.getTime();
      });

    // Process up to availableSlots jobs
    const jobsToProcess = pendingJobs.slice(0, availableSlots);

    for (const job of jobsToProcess) {
      this.processJob(job.id).catch(err => {
        logger.error(`Error processing job ${job.id}: ${err}`);
      });
    }
  }

  /**
   * Process a single job
   *
   * @param jobId Job ID
   */
  private async processJob(jobId: string): Promise<void> {
    const job = this.jobs.get(jobId);
    if (!job) {
      return;
    }

    // Update job status
    job.status = 'processing';
    job.startedAt = new Date();
    job.attempts++;
    this.processingJobs.add(jobId);

    // Persist job state
    await this.persistJob(job);

    logger.info(`Processing PDF job ${jobId}: ${job.filePath} (Attempt ${job.attempts}/${job.maxAttempts})`);

    // Publish job-started event
    await this.adapter.publishJobStarted({
      id: jobId,
      status: 'processing',
      priority: job.priority,
      filePath: job.filePath,
      attempts: job.attempts,
      maxAttempts: job.maxAttempts
    });

    try {
      // Process PDF using the existing processPdfCatalog function
      // Pass the user ID for MCP integration
      const result = await processPdfCatalog(job.filePath, {
        ...job.options,
        userId: job.options.userId // Ensure user ID is passed for MCP integration
      });

      // Update job progress and status
      job.progress = {
        totalPages: result.totalPages,
        processedPages: result.processedPages.length,
        extractedImages: result.processedPages.reduce((sum, page) => sum + page.images.length, 0),
        processedImages: result.processedPages.reduce((sum, page) => sum + page.associations.length, 0),
        materialsCreated: result.materials.length
      };
      job.status = 'completed';
      job.completedAt = new Date();

      logger.info(`Completed PDF job ${jobId}: ${result.materials.length} materials created`);

      // Publish job-completed event
      await this.adapter.publishJobCompleted({
        id: jobId,
        status: 'completed',
        priority: job.priority,
        filePath: job.filePath,
        progress: 100,
        materialsCreated: result.materials.length,
        totalPages: job.progress?.totalPages,
        processedPages: job.progress?.processedPages
      });
    } catch (err) {
      // Handle job failure
      job.error = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to process PDF job ${jobId}: ${job.error}`);

      // Publish job-failed event
      await this.adapter.publishJobFailed({
        id: jobId,
        status: job.attempts < job.maxAttempts ? 'retrying' : 'failed',
        priority: job.priority,
        filePath: job.filePath,
        attempts: job.attempts,
        maxAttempts: job.maxAttempts,
        error: job.error
      });

      // Check if we should retry
      if (job.attempts < job.maxAttempts) {
        job.status = 'retrying';
        logger.info(`Will retry PDF job ${jobId} in ${this.config.retryDelay / 1000} seconds`);

        // Schedule retry after delay
        setTimeout(() => {
          // Only retry if the job is still in retrying state
          const updatedJob = this.jobs.get(jobId);
          if (updatedJob && updatedJob.status === 'retrying') {
            this.processJob(jobId).catch(err => {
              logger.error(`Error processing job ${jobId}: ${err}`);
            });
          }
        }, this.config.retryDelay);
      } else {
        job.status = 'failed';
        job.completedAt = new Date();
        logger.error(`PDF job ${jobId} failed after ${job.attempts} attempts`);
      }
    } finally {
      // Remove job from processing set
      this.processingJobs.delete(jobId);

      // Persist job state
      await this.persistJob(job);
    }
  }

  /**
   * Persist the queue state to disk
   */
  private async persist(): Promise<void> {
    try {
      // Persist each job to its own file
      for (const job of this.jobs.values()) {
        await this.persistJob(job);
      }

      logger.debug(`Persisted PDF queue state: ${this.jobs.size} jobs`);
    } catch (err) {
      logger.error(`Failed to persist PDF queue state: ${err}`);
    }
  }

  /**
   * Persist a single job to disk
   *
   * @param job Job to persist
   */
  private async persistJob(job: QueueJob): Promise<void> {
    try {
      const jobFile = path.join(this.config.persistPath, `${job.id}.json`);
      const jobJson = JSON.stringify(job, null, 2);
      fs.writeFileSync(jobFile, jobJson);
    } catch (err) {
      logger.error(`Failed to persist job ${job.id}: ${err}`);
    }
  }

  /**
   * Restore queue state from disk
   */
  private restore(): void {
    try {
      // Get all job files
      const files = fs.readdirSync(this.config.persistPath);
      const jobFiles = files.filter(file => file.endsWith('.json'));

      // Restore each job
      for (const file of jobFiles) {
        try {
          const jobFile = path.join(this.config.persistPath, file);
          const jobJson = fs.readFileSync(jobFile, 'utf-8');
          const job = JSON.parse(jobJson) as QueueJob;

          // Convert date strings back to Date objects
          job.createdAt = new Date(job.createdAt);
          if (job.startedAt) job.startedAt = new Date(job.startedAt);
          if (job.completedAt) job.completedAt = new Date(job.completedAt);

          // Reset processing jobs to retrying
          if (job.status === 'processing') {
            job.status = 'retrying';
          }

          // Add job to queue
          this.jobs.set(job.id, job);
        } catch (err) {
          logger.error(`Failed to restore job from ${file}: ${err}`);
        }
      }

      logger.info(`Restored PDF queue state: ${this.jobs.size} jobs`);

      // Start processing
      this.isProcessing = true;
    } catch (err) {
      logger.error(`Failed to restore PDF queue state: ${err}`);
      // Start processing anyway
      this.isProcessing = true;
    }
  }
}

// Create a singleton instance
export const pdfQueue = new PDFQueue();

// Export default instance
export default pdfQueue;